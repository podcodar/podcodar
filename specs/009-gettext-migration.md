# Spec 009: Migrate Site Copy to Gettext for Internationalization

## Overview

This specification outlines the migration of all hardcoded site copy in the Podcodar application to use Phoenix's built-in Gettext library for internationalization (i18n). The goal is to support English (en-US) and Portuguese (pt-BR) locales, making text management and future translations easier.

## Background

Currently, all user-facing text in templates, LiveViews, and other code is hardcoded as strings. This makes it difficult to support multiple languages and maintain consistency across the application. By migrating to Gettext, we can:

- Centralize all translatable strings in .po files
- Support easy addition of new locales
- Use standard i18n practices with pluralization and interpolation
- Leverage existing Phoenix tooling for extraction and compilation

## Requirements

- Support for en-US and pt-BR locales
- All user-facing text must be translatable
- Maintain existing functionality without breaking changes
- Use Phoenix's default Gettext backend (PodcodarWeb.Gettext)
- Enable locale switching (future enhancement, out of scope for this migration)

## Implementation Plan

### Phase 1: Configuration and Setup

1. **Update Configuration**
   - Add locale configuration to `config/config.exs`:
     ```elixir
     config :podcodar, PodcodarWeb.Gettext, locales: [:en, :"pt-BR"]
     ```
   - Set default locale to pt-BR since the project uses pt-BR for user-facing content

2. **Ensure Gettext Backend is Defined**
   - Verify `PodcodarWeb.Gettext` module exists (generated by Phoenix)
   - Confirm it's configured in `lib/podcodar_web.ex` or similar

### Phase 2: String Identification and Replacement

3. **Identify All Hardcoded Strings**
   - Search templates (.html.heex files) for hardcoded text
   - Search LiveView modules for hardcoded text in assigns or flash messages
   - Search controller responses and email templates
   - Use grep to find patterns like `">text<"` or `"text"` in relevant files

4. **Replace Strings with Gettext Calls**
   - In templates: Replace `<%= "Hello" %>` with `<%= gettext("Hello") %>`
   - In LiveViews: Replace assigns with `assign(socket, :title, gettext("Title"))`
   - Handle interpolation: `gettext("Hello %{name}", name: @name)`
   - Handle pluralization where applicable: `ngettext("1 item", "%{count} items", count)`
   - Use domains if organizing by feature (e.g., `dgettext("admin", "Delete")`)

5. **Update Imports**
   - Ensure `PodcodarWeb.Gettext` is imported in web.ex for templates
   - Import in LiveView modules if needed: `import PodcodarWeb.Gettext`

### Phase 3: Translation Extraction and Setup

6. **Extract Translations**
   - Run `mix gettext.extract` to generate .pot template files
   - Review generated files in `priv/gettext/`

7. **Create Locale Files**
   - Run `mix gettext.merge priv/gettext` for default (en-US)
   - Run `mix gettext.merge priv/gettext --locale pt-BR` for pt-BR
   - This creates .po files in `priv/gettext/{locale}/LC_MESSAGES/`

8. **Provide Initial Translations**
   - For pt-BR .po file: Add Portuguese translations for all msgid entries
   - For en-US .po file: Keep as-is (default English) or provide American English variants if needed
   - Use tools like Lokalise or manual editing for translations

9. **Compile Translations**
   - Run `mix gettext.compile` to generate binary .mo files
   - Verify compilation succeeds

### Phase 4: Testing and Validation

10. **Update Tests**
    - Modify any tests that assert on hardcoded text to use translated strings
    - Consider using `Gettext.put_locale/1` in tests to test different locales

11. **Functional Testing**
    - Test application in both locales (requires locale switching, see Phase 5)
    - Verify all text is translated correctly
    - Check for missing translations (should fall back to msgid)

12. **Performance Testing**
    - Ensure no performance regression from Gettext lookups
    - Verify compilation times are acceptable

### Phase 5: Locale Switching (Future Enhancement)

13. **Implement Locale Detection**
    - Add plug to detect locale from URL params, session, or Accept-Language header
    - Store locale in session or cookie
    - Set locale per process with `Gettext.put_locale/1`

14. **Add Locale Switcher UI**
    - Create UI component to switch between supported locales
    - Update routes to include locale prefix if desired

## File Structure After Migration

```
priv/gettext/
├── default.pot
├── en/
│   └── LC_MESSAGES/
│       └── default.po
└── pt-BR/
    └── LC_MESSAGES/
        └── default.po
```

## Commands Reference

- Extract: `mix gettext.extract`
- Merge: `mix gettext.merge priv/gettext [--locale LOCALE]`
- Compile: `mix gettext.compile`
- Update: `mix gettext.extract --merge`

## Risks and Mitigations

- **Missing Translations**: All strings will fall back to the original msgid if translation is missing
- **Breaking Changes**: Thorough testing required; use feature flags if needed
- **Performance**: Gettext is fast, but monitor for any impact
- **Context Loss**: Ensure msgid provides enough context for translators

## Rollback Plan

If issues arise:
1. Revert code changes to remove gettext calls
2. Remove .po files and keep only .pot if needed
3. Remove locale configuration
4. Re-hardcode strings temporarily

## Acceptance Criteria

- All user-facing text uses gettext calls
- Application compiles and runs without errors
- Translations are extracted and compiled successfully
- Both en-US and pt-BR .po files exist with appropriate translations
- No hardcoded strings remain in templates/LiveViews (except error messages if using domains)

## Resources

- [Phoenix Gettext Documentation](https://hexdocs.pm/gettext/)
- [Phoenix i18n Guide](https://hexdocs.pm/phoenix/i18n.html)
- [Gettext GitHub](https://github.com/elixir-gettext/gettext)
